// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/r-heap47/skylr/skylr-overseer/internal/provisioner.ShardProvisioner -o shard_provisioner_mock.go -n ShardProvisionerMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ShardProvisionerMock implements mm_provisioner.ShardProvisioner
type ShardProvisionerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeprovision          func(ctx context.Context, addr string) (err error)
	funcDeprovisionOrigin    string
	inspectFuncDeprovision   func(ctx context.Context, addr string)
	afterDeprovisionCounter  uint64
	beforeDeprovisionCounter uint64
	DeprovisionMock          mShardProvisionerMockDeprovision

	funcProvision          func(ctx context.Context) (addr string, err error)
	funcProvisionOrigin    string
	inspectFuncProvision   func(ctx context.Context)
	afterProvisionCounter  uint64
	beforeProvisionCounter uint64
	ProvisionMock          mShardProvisionerMockProvision
}

// NewShardProvisionerMock returns a mock for mm_provisioner.ShardProvisioner
func NewShardProvisionerMock(t minimock.Tester) *ShardProvisionerMock {
	m := &ShardProvisionerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeprovisionMock = mShardProvisionerMockDeprovision{mock: m}
	m.DeprovisionMock.callArgs = []*ShardProvisionerMockDeprovisionParams{}

	m.ProvisionMock = mShardProvisionerMockProvision{mock: m}
	m.ProvisionMock.callArgs = []*ShardProvisionerMockProvisionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mShardProvisionerMockDeprovision struct {
	optional           bool
	mock               *ShardProvisionerMock
	defaultExpectation *ShardProvisionerMockDeprovisionExpectation
	expectations       []*ShardProvisionerMockDeprovisionExpectation

	callArgs []*ShardProvisionerMockDeprovisionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ShardProvisionerMockDeprovisionExpectation specifies expectation struct of the ShardProvisioner.Deprovision
type ShardProvisionerMockDeprovisionExpectation struct {
	mock               *ShardProvisionerMock
	params             *ShardProvisionerMockDeprovisionParams
	paramPtrs          *ShardProvisionerMockDeprovisionParamPtrs
	expectationOrigins ShardProvisionerMockDeprovisionExpectationOrigins
	results            *ShardProvisionerMockDeprovisionResults
	returnOrigin       string
	Counter            uint64
}

// ShardProvisionerMockDeprovisionParams contains parameters of the ShardProvisioner.Deprovision
type ShardProvisionerMockDeprovisionParams struct {
	ctx  context.Context
	addr string
}

// ShardProvisionerMockDeprovisionParamPtrs contains pointers to parameters of the ShardProvisioner.Deprovision
type ShardProvisionerMockDeprovisionParamPtrs struct {
	ctx  *context.Context
	addr *string
}

// ShardProvisionerMockDeprovisionResults contains results of the ShardProvisioner.Deprovision
type ShardProvisionerMockDeprovisionResults struct {
	err error
}

// ShardProvisionerMockDeprovisionOrigins contains origins of expectations of the ShardProvisioner.Deprovision
type ShardProvisionerMockDeprovisionExpectationOrigins struct {
	origin     string
	originCtx  string
	originAddr string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeprovision *mShardProvisionerMockDeprovision) Optional() *mShardProvisionerMockDeprovision {
	mmDeprovision.optional = true
	return mmDeprovision
}

// Expect sets up expected params for ShardProvisioner.Deprovision
func (mmDeprovision *mShardProvisionerMockDeprovision) Expect(ctx context.Context, addr string) *mShardProvisionerMockDeprovision {
	if mmDeprovision.mock.funcDeprovision != nil {
		mmDeprovision.mock.t.Fatalf("ShardProvisionerMock.Deprovision mock is already set by Set")
	}

	if mmDeprovision.defaultExpectation == nil {
		mmDeprovision.defaultExpectation = &ShardProvisionerMockDeprovisionExpectation{}
	}

	if mmDeprovision.defaultExpectation.paramPtrs != nil {
		mmDeprovision.mock.t.Fatalf("ShardProvisionerMock.Deprovision mock is already set by ExpectParams functions")
	}

	mmDeprovision.defaultExpectation.params = &ShardProvisionerMockDeprovisionParams{ctx, addr}
	mmDeprovision.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeprovision.expectations {
		if minimock.Equal(e.params, mmDeprovision.defaultExpectation.params) {
			mmDeprovision.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeprovision.defaultExpectation.params)
		}
	}

	return mmDeprovision
}

// ExpectCtxParam1 sets up expected param ctx for ShardProvisioner.Deprovision
func (mmDeprovision *mShardProvisionerMockDeprovision) ExpectCtxParam1(ctx context.Context) *mShardProvisionerMockDeprovision {
	if mmDeprovision.mock.funcDeprovision != nil {
		mmDeprovision.mock.t.Fatalf("ShardProvisionerMock.Deprovision mock is already set by Set")
	}

	if mmDeprovision.defaultExpectation == nil {
		mmDeprovision.defaultExpectation = &ShardProvisionerMockDeprovisionExpectation{}
	}

	if mmDeprovision.defaultExpectation.params != nil {
		mmDeprovision.mock.t.Fatalf("ShardProvisionerMock.Deprovision mock is already set by Expect")
	}

	if mmDeprovision.defaultExpectation.paramPtrs == nil {
		mmDeprovision.defaultExpectation.paramPtrs = &ShardProvisionerMockDeprovisionParamPtrs{}
	}
	mmDeprovision.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeprovision.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeprovision
}

// ExpectAddrParam2 sets up expected param addr for ShardProvisioner.Deprovision
func (mmDeprovision *mShardProvisionerMockDeprovision) ExpectAddrParam2(addr string) *mShardProvisionerMockDeprovision {
	if mmDeprovision.mock.funcDeprovision != nil {
		mmDeprovision.mock.t.Fatalf("ShardProvisionerMock.Deprovision mock is already set by Set")
	}

	if mmDeprovision.defaultExpectation == nil {
		mmDeprovision.defaultExpectation = &ShardProvisionerMockDeprovisionExpectation{}
	}

	if mmDeprovision.defaultExpectation.params != nil {
		mmDeprovision.mock.t.Fatalf("ShardProvisionerMock.Deprovision mock is already set by Expect")
	}

	if mmDeprovision.defaultExpectation.paramPtrs == nil {
		mmDeprovision.defaultExpectation.paramPtrs = &ShardProvisionerMockDeprovisionParamPtrs{}
	}
	mmDeprovision.defaultExpectation.paramPtrs.addr = &addr
	mmDeprovision.defaultExpectation.expectationOrigins.originAddr = minimock.CallerInfo(1)

	return mmDeprovision
}

// Inspect accepts an inspector function that has same arguments as the ShardProvisioner.Deprovision
func (mmDeprovision *mShardProvisionerMockDeprovision) Inspect(f func(ctx context.Context, addr string)) *mShardProvisionerMockDeprovision {
	if mmDeprovision.mock.inspectFuncDeprovision != nil {
		mmDeprovision.mock.t.Fatalf("Inspect function is already set for ShardProvisionerMock.Deprovision")
	}

	mmDeprovision.mock.inspectFuncDeprovision = f

	return mmDeprovision
}

// Return sets up results that will be returned by ShardProvisioner.Deprovision
func (mmDeprovision *mShardProvisionerMockDeprovision) Return(err error) *ShardProvisionerMock {
	if mmDeprovision.mock.funcDeprovision != nil {
		mmDeprovision.mock.t.Fatalf("ShardProvisionerMock.Deprovision mock is already set by Set")
	}

	if mmDeprovision.defaultExpectation == nil {
		mmDeprovision.defaultExpectation = &ShardProvisionerMockDeprovisionExpectation{mock: mmDeprovision.mock}
	}
	mmDeprovision.defaultExpectation.results = &ShardProvisionerMockDeprovisionResults{err}
	mmDeprovision.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeprovision.mock
}

// Set uses given function f to mock the ShardProvisioner.Deprovision method
func (mmDeprovision *mShardProvisionerMockDeprovision) Set(f func(ctx context.Context, addr string) (err error)) *ShardProvisionerMock {
	if mmDeprovision.defaultExpectation != nil {
		mmDeprovision.mock.t.Fatalf("Default expectation is already set for the ShardProvisioner.Deprovision method")
	}

	if len(mmDeprovision.expectations) > 0 {
		mmDeprovision.mock.t.Fatalf("Some expectations are already set for the ShardProvisioner.Deprovision method")
	}

	mmDeprovision.mock.funcDeprovision = f
	mmDeprovision.mock.funcDeprovisionOrigin = minimock.CallerInfo(1)
	return mmDeprovision.mock
}

// When sets expectation for the ShardProvisioner.Deprovision which will trigger the result defined by the following
// Then helper
func (mmDeprovision *mShardProvisionerMockDeprovision) When(ctx context.Context, addr string) *ShardProvisionerMockDeprovisionExpectation {
	if mmDeprovision.mock.funcDeprovision != nil {
		mmDeprovision.mock.t.Fatalf("ShardProvisionerMock.Deprovision mock is already set by Set")
	}

	expectation := &ShardProvisionerMockDeprovisionExpectation{
		mock:               mmDeprovision.mock,
		params:             &ShardProvisionerMockDeprovisionParams{ctx, addr},
		expectationOrigins: ShardProvisionerMockDeprovisionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeprovision.expectations = append(mmDeprovision.expectations, expectation)
	return expectation
}

// Then sets up ShardProvisioner.Deprovision return parameters for the expectation previously defined by the When method
func (e *ShardProvisionerMockDeprovisionExpectation) Then(err error) *ShardProvisionerMock {
	e.results = &ShardProvisionerMockDeprovisionResults{err}
	return e.mock
}

// Times sets number of times ShardProvisioner.Deprovision should be invoked
func (mmDeprovision *mShardProvisionerMockDeprovision) Times(n uint64) *mShardProvisionerMockDeprovision {
	if n == 0 {
		mmDeprovision.mock.t.Fatalf("Times of ShardProvisionerMock.Deprovision mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeprovision.expectedInvocations, n)
	mmDeprovision.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeprovision
}

func (mmDeprovision *mShardProvisionerMockDeprovision) invocationsDone() bool {
	if len(mmDeprovision.expectations) == 0 && mmDeprovision.defaultExpectation == nil && mmDeprovision.mock.funcDeprovision == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeprovision.mock.afterDeprovisionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeprovision.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Deprovision implements mm_provisioner.ShardProvisioner
func (mmDeprovision *ShardProvisionerMock) Deprovision(ctx context.Context, addr string) (err error) {
	mm_atomic.AddUint64(&mmDeprovision.beforeDeprovisionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeprovision.afterDeprovisionCounter, 1)

	mmDeprovision.t.Helper()

	if mmDeprovision.inspectFuncDeprovision != nil {
		mmDeprovision.inspectFuncDeprovision(ctx, addr)
	}

	mm_params := ShardProvisionerMockDeprovisionParams{ctx, addr}

	// Record call args
	mmDeprovision.DeprovisionMock.mutex.Lock()
	mmDeprovision.DeprovisionMock.callArgs = append(mmDeprovision.DeprovisionMock.callArgs, &mm_params)
	mmDeprovision.DeprovisionMock.mutex.Unlock()

	for _, e := range mmDeprovision.DeprovisionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeprovision.DeprovisionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeprovision.DeprovisionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeprovision.DeprovisionMock.defaultExpectation.params
		mm_want_ptrs := mmDeprovision.DeprovisionMock.defaultExpectation.paramPtrs

		mm_got := ShardProvisionerMockDeprovisionParams{ctx, addr}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeprovision.t.Errorf("ShardProvisionerMock.Deprovision got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeprovision.DeprovisionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.addr != nil && !minimock.Equal(*mm_want_ptrs.addr, mm_got.addr) {
				mmDeprovision.t.Errorf("ShardProvisionerMock.Deprovision got unexpected parameter addr, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeprovision.DeprovisionMock.defaultExpectation.expectationOrigins.originAddr, *mm_want_ptrs.addr, mm_got.addr, minimock.Diff(*mm_want_ptrs.addr, mm_got.addr))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeprovision.t.Errorf("ShardProvisionerMock.Deprovision got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeprovision.DeprovisionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeprovision.DeprovisionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeprovision.t.Fatal("No results are set for the ShardProvisionerMock.Deprovision")
		}
		return (*mm_results).err
	}
	if mmDeprovision.funcDeprovision != nil {
		return mmDeprovision.funcDeprovision(ctx, addr)
	}
	mmDeprovision.t.Fatalf("Unexpected call to ShardProvisionerMock.Deprovision. %v %v", ctx, addr)
	return
}

// DeprovisionAfterCounter returns a count of finished ShardProvisionerMock.Deprovision invocations
func (mmDeprovision *ShardProvisionerMock) DeprovisionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeprovision.afterDeprovisionCounter)
}

// DeprovisionBeforeCounter returns a count of ShardProvisionerMock.Deprovision invocations
func (mmDeprovision *ShardProvisionerMock) DeprovisionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeprovision.beforeDeprovisionCounter)
}

// Calls returns a list of arguments used in each call to ShardProvisionerMock.Deprovision.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeprovision *mShardProvisionerMockDeprovision) Calls() []*ShardProvisionerMockDeprovisionParams {
	mmDeprovision.mutex.RLock()

	argCopy := make([]*ShardProvisionerMockDeprovisionParams, len(mmDeprovision.callArgs))
	copy(argCopy, mmDeprovision.callArgs)

	mmDeprovision.mutex.RUnlock()

	return argCopy
}

// MinimockDeprovisionDone returns true if the count of the Deprovision invocations corresponds
// the number of defined expectations
func (m *ShardProvisionerMock) MinimockDeprovisionDone() bool {
	if m.DeprovisionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeprovisionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeprovisionMock.invocationsDone()
}

// MinimockDeprovisionInspect logs each unmet expectation
func (m *ShardProvisionerMock) MinimockDeprovisionInspect() {
	for _, e := range m.DeprovisionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShardProvisionerMock.Deprovision at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeprovisionCounter := mm_atomic.LoadUint64(&m.afterDeprovisionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeprovisionMock.defaultExpectation != nil && afterDeprovisionCounter < 1 {
		if m.DeprovisionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ShardProvisionerMock.Deprovision at\n%s", m.DeprovisionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ShardProvisionerMock.Deprovision at\n%s with params: %#v", m.DeprovisionMock.defaultExpectation.expectationOrigins.origin, *m.DeprovisionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeprovision != nil && afterDeprovisionCounter < 1 {
		m.t.Errorf("Expected call to ShardProvisionerMock.Deprovision at\n%s", m.funcDeprovisionOrigin)
	}

	if !m.DeprovisionMock.invocationsDone() && afterDeprovisionCounter > 0 {
		m.t.Errorf("Expected %d calls to ShardProvisionerMock.Deprovision at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeprovisionMock.expectedInvocations), m.DeprovisionMock.expectedInvocationsOrigin, afterDeprovisionCounter)
	}
}

type mShardProvisionerMockProvision struct {
	optional           bool
	mock               *ShardProvisionerMock
	defaultExpectation *ShardProvisionerMockProvisionExpectation
	expectations       []*ShardProvisionerMockProvisionExpectation

	callArgs []*ShardProvisionerMockProvisionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ShardProvisionerMockProvisionExpectation specifies expectation struct of the ShardProvisioner.Provision
type ShardProvisionerMockProvisionExpectation struct {
	mock               *ShardProvisionerMock
	params             *ShardProvisionerMockProvisionParams
	paramPtrs          *ShardProvisionerMockProvisionParamPtrs
	expectationOrigins ShardProvisionerMockProvisionExpectationOrigins
	results            *ShardProvisionerMockProvisionResults
	returnOrigin       string
	Counter            uint64
}

// ShardProvisionerMockProvisionParams contains parameters of the ShardProvisioner.Provision
type ShardProvisionerMockProvisionParams struct {
	ctx context.Context
}

// ShardProvisionerMockProvisionParamPtrs contains pointers to parameters of the ShardProvisioner.Provision
type ShardProvisionerMockProvisionParamPtrs struct {
	ctx *context.Context
}

// ShardProvisionerMockProvisionResults contains results of the ShardProvisioner.Provision
type ShardProvisionerMockProvisionResults struct {
	addr string
	err  error
}

// ShardProvisionerMockProvisionOrigins contains origins of expectations of the ShardProvisioner.Provision
type ShardProvisionerMockProvisionExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProvision *mShardProvisionerMockProvision) Optional() *mShardProvisionerMockProvision {
	mmProvision.optional = true
	return mmProvision
}

// Expect sets up expected params for ShardProvisioner.Provision
func (mmProvision *mShardProvisionerMockProvision) Expect(ctx context.Context) *mShardProvisionerMockProvision {
	if mmProvision.mock.funcProvision != nil {
		mmProvision.mock.t.Fatalf("ShardProvisionerMock.Provision mock is already set by Set")
	}

	if mmProvision.defaultExpectation == nil {
		mmProvision.defaultExpectation = &ShardProvisionerMockProvisionExpectation{}
	}

	if mmProvision.defaultExpectation.paramPtrs != nil {
		mmProvision.mock.t.Fatalf("ShardProvisionerMock.Provision mock is already set by ExpectParams functions")
	}

	mmProvision.defaultExpectation.params = &ShardProvisionerMockProvisionParams{ctx}
	mmProvision.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProvision.expectations {
		if minimock.Equal(e.params, mmProvision.defaultExpectation.params) {
			mmProvision.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProvision.defaultExpectation.params)
		}
	}

	return mmProvision
}

// ExpectCtxParam1 sets up expected param ctx for ShardProvisioner.Provision
func (mmProvision *mShardProvisionerMockProvision) ExpectCtxParam1(ctx context.Context) *mShardProvisionerMockProvision {
	if mmProvision.mock.funcProvision != nil {
		mmProvision.mock.t.Fatalf("ShardProvisionerMock.Provision mock is already set by Set")
	}

	if mmProvision.defaultExpectation == nil {
		mmProvision.defaultExpectation = &ShardProvisionerMockProvisionExpectation{}
	}

	if mmProvision.defaultExpectation.params != nil {
		mmProvision.mock.t.Fatalf("ShardProvisionerMock.Provision mock is already set by Expect")
	}

	if mmProvision.defaultExpectation.paramPtrs == nil {
		mmProvision.defaultExpectation.paramPtrs = &ShardProvisionerMockProvisionParamPtrs{}
	}
	mmProvision.defaultExpectation.paramPtrs.ctx = &ctx
	mmProvision.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProvision
}

// Inspect accepts an inspector function that has same arguments as the ShardProvisioner.Provision
func (mmProvision *mShardProvisionerMockProvision) Inspect(f func(ctx context.Context)) *mShardProvisionerMockProvision {
	if mmProvision.mock.inspectFuncProvision != nil {
		mmProvision.mock.t.Fatalf("Inspect function is already set for ShardProvisionerMock.Provision")
	}

	mmProvision.mock.inspectFuncProvision = f

	return mmProvision
}

// Return sets up results that will be returned by ShardProvisioner.Provision
func (mmProvision *mShardProvisionerMockProvision) Return(addr string, err error) *ShardProvisionerMock {
	if mmProvision.mock.funcProvision != nil {
		mmProvision.mock.t.Fatalf("ShardProvisionerMock.Provision mock is already set by Set")
	}

	if mmProvision.defaultExpectation == nil {
		mmProvision.defaultExpectation = &ShardProvisionerMockProvisionExpectation{mock: mmProvision.mock}
	}
	mmProvision.defaultExpectation.results = &ShardProvisionerMockProvisionResults{addr, err}
	mmProvision.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProvision.mock
}

// Set uses given function f to mock the ShardProvisioner.Provision method
func (mmProvision *mShardProvisionerMockProvision) Set(f func(ctx context.Context) (addr string, err error)) *ShardProvisionerMock {
	if mmProvision.defaultExpectation != nil {
		mmProvision.mock.t.Fatalf("Default expectation is already set for the ShardProvisioner.Provision method")
	}

	if len(mmProvision.expectations) > 0 {
		mmProvision.mock.t.Fatalf("Some expectations are already set for the ShardProvisioner.Provision method")
	}

	mmProvision.mock.funcProvision = f
	mmProvision.mock.funcProvisionOrigin = minimock.CallerInfo(1)
	return mmProvision.mock
}

// When sets expectation for the ShardProvisioner.Provision which will trigger the result defined by the following
// Then helper
func (mmProvision *mShardProvisionerMockProvision) When(ctx context.Context) *ShardProvisionerMockProvisionExpectation {
	if mmProvision.mock.funcProvision != nil {
		mmProvision.mock.t.Fatalf("ShardProvisionerMock.Provision mock is already set by Set")
	}

	expectation := &ShardProvisionerMockProvisionExpectation{
		mock:               mmProvision.mock,
		params:             &ShardProvisionerMockProvisionParams{ctx},
		expectationOrigins: ShardProvisionerMockProvisionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProvision.expectations = append(mmProvision.expectations, expectation)
	return expectation
}

// Then sets up ShardProvisioner.Provision return parameters for the expectation previously defined by the When method
func (e *ShardProvisionerMockProvisionExpectation) Then(addr string, err error) *ShardProvisionerMock {
	e.results = &ShardProvisionerMockProvisionResults{addr, err}
	return e.mock
}

// Times sets number of times ShardProvisioner.Provision should be invoked
func (mmProvision *mShardProvisionerMockProvision) Times(n uint64) *mShardProvisionerMockProvision {
	if n == 0 {
		mmProvision.mock.t.Fatalf("Times of ShardProvisionerMock.Provision mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProvision.expectedInvocations, n)
	mmProvision.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProvision
}

func (mmProvision *mShardProvisionerMockProvision) invocationsDone() bool {
	if len(mmProvision.expectations) == 0 && mmProvision.defaultExpectation == nil && mmProvision.mock.funcProvision == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProvision.mock.afterProvisionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProvision.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Provision implements mm_provisioner.ShardProvisioner
func (mmProvision *ShardProvisionerMock) Provision(ctx context.Context) (addr string, err error) {
	mm_atomic.AddUint64(&mmProvision.beforeProvisionCounter, 1)
	defer mm_atomic.AddUint64(&mmProvision.afterProvisionCounter, 1)

	mmProvision.t.Helper()

	if mmProvision.inspectFuncProvision != nil {
		mmProvision.inspectFuncProvision(ctx)
	}

	mm_params := ShardProvisionerMockProvisionParams{ctx}

	// Record call args
	mmProvision.ProvisionMock.mutex.Lock()
	mmProvision.ProvisionMock.callArgs = append(mmProvision.ProvisionMock.callArgs, &mm_params)
	mmProvision.ProvisionMock.mutex.Unlock()

	for _, e := range mmProvision.ProvisionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.addr, e.results.err
		}
	}

	if mmProvision.ProvisionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProvision.ProvisionMock.defaultExpectation.Counter, 1)
		mm_want := mmProvision.ProvisionMock.defaultExpectation.params
		mm_want_ptrs := mmProvision.ProvisionMock.defaultExpectation.paramPtrs

		mm_got := ShardProvisionerMockProvisionParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProvision.t.Errorf("ShardProvisionerMock.Provision got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProvision.ProvisionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProvision.t.Errorf("ShardProvisionerMock.Provision got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProvision.ProvisionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProvision.ProvisionMock.defaultExpectation.results
		if mm_results == nil {
			mmProvision.t.Fatal("No results are set for the ShardProvisionerMock.Provision")
		}
		return (*mm_results).addr, (*mm_results).err
	}
	if mmProvision.funcProvision != nil {
		return mmProvision.funcProvision(ctx)
	}
	mmProvision.t.Fatalf("Unexpected call to ShardProvisionerMock.Provision. %v", ctx)
	return
}

// ProvisionAfterCounter returns a count of finished ShardProvisionerMock.Provision invocations
func (mmProvision *ShardProvisionerMock) ProvisionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProvision.afterProvisionCounter)
}

// ProvisionBeforeCounter returns a count of ShardProvisionerMock.Provision invocations
func (mmProvision *ShardProvisionerMock) ProvisionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProvision.beforeProvisionCounter)
}

// Calls returns a list of arguments used in each call to ShardProvisionerMock.Provision.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProvision *mShardProvisionerMockProvision) Calls() []*ShardProvisionerMockProvisionParams {
	mmProvision.mutex.RLock()

	argCopy := make([]*ShardProvisionerMockProvisionParams, len(mmProvision.callArgs))
	copy(argCopy, mmProvision.callArgs)

	mmProvision.mutex.RUnlock()

	return argCopy
}

// MinimockProvisionDone returns true if the count of the Provision invocations corresponds
// the number of defined expectations
func (m *ShardProvisionerMock) MinimockProvisionDone() bool {
	if m.ProvisionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProvisionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProvisionMock.invocationsDone()
}

// MinimockProvisionInspect logs each unmet expectation
func (m *ShardProvisionerMock) MinimockProvisionInspect() {
	for _, e := range m.ProvisionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShardProvisionerMock.Provision at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProvisionCounter := mm_atomic.LoadUint64(&m.afterProvisionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProvisionMock.defaultExpectation != nil && afterProvisionCounter < 1 {
		if m.ProvisionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ShardProvisionerMock.Provision at\n%s", m.ProvisionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ShardProvisionerMock.Provision at\n%s with params: %#v", m.ProvisionMock.defaultExpectation.expectationOrigins.origin, *m.ProvisionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProvision != nil && afterProvisionCounter < 1 {
		m.t.Errorf("Expected call to ShardProvisionerMock.Provision at\n%s", m.funcProvisionOrigin)
	}

	if !m.ProvisionMock.invocationsDone() && afterProvisionCounter > 0 {
		m.t.Errorf("Expected %d calls to ShardProvisionerMock.Provision at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProvisionMock.expectedInvocations), m.ProvisionMock.expectedInvocationsOrigin, afterProvisionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ShardProvisionerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeprovisionInspect()

			m.MinimockProvisionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ShardProvisionerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ShardProvisionerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeprovisionDone() &&
		m.MinimockProvisionDone()
}
